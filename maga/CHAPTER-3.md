
# Глава 3: Проектирование и реализация доверенной операционной системы

 ## 3.1. Соображения по выбору интерфейса

  ### 3.1.1. Базовое API ДСИ: Интерфейс взаимодействия между мирами

   #### 3.1.1.1. Введение в TEE API

   Базовое API TEE (Trusted Execution Environment Internal Core API)
   определяет функции, которые клиенты нормального мира
   используют для взаимодействия с доверенными приложениями,
   работающими в Secure OS.
   Этот интерфейс должен предоставлять
   механизмы для установки соединения,
   обмена данными, вызова защищённых функций
   и управления жизненным циклом безопасных сессий.

   Рассмотрим варианты, на которые можно обратить
   внимание при выборе интерфейса
   для доверенной операционной системы.

   #### 3.1.1.2. OP-TEE для RISC-V

   OP-TEE (Open Portable TEE) -
   это известная среда доверенного исполнения
   с открытым исходным кодом,
   изначально разработанная для технологии Arm TrustZone.
   OP-TEE реализует значительную часть спецификаций
   GlobalPlatform TEE, предоставляя богатый набор функций,
   включая внутренний API ядра TEE
   (TEE Internal Core API) для разработки TA
   и полнофункциональный клиентский API TEE.

   Хотя OP-TEE представляет собой зрелое
   и широко распространённое решение TEE,
   его архитектура сопряжена с определёнными особенностями.
   OP-TEE сама по себе является
   небольшой безопасной операционной системой,
   обычно работающей параллельно
   с Rich OS. Для данного проекта, прямое использование
   API OP-TEE потребовало бы либо значительных усилий
   по портированию и адаптации,
   либо диктовало бы архитектурные решения,
   менее соответствующие целям проекта по созданию минимальной,
   глубоко проработанной доверенной кодовой базы (TCB),
   адаптированной под World Guard.

   #### 3.1.1.3. Разработка собственного минимального интерфейса на базе GlobalPlatform TEE

   Альтернативным подходом рассматривалась
   разработка собственного,
   минимально необходимого интерфейса TEE,
   основанного на спецификациях
   GlobalPlatform TEE Internal Core API.
   Этот путь предполагает реализацию
   только ключевых функций API,
   необходимых для базового взаимодействия с TA:
   управление контекстами, сессиями, разделяемой памятью и вызовом команд.

   Разработка собственного минимального
   интерфейса имела несколько преимуществ:

  - Снижение сложности: <br>
    Меньший набор функций API
    упрощает реализацию Secure OS,
    что потенциально ведёт к уменьшению
    доверенной кодовой базы (TCB)
    и поверхности атак.

  - Адаптация под World Guard: <br>
    Интерфейс мог бы быть специально спроектирован
    для эффективного использования двухмировой модели
    расширения World Guard и его примитивов
    межмирового взаимодействия.
    Например, парадигма обмена данными
    через разделяемую память,
    предусмотренная проектом,
    может быть напрямую отражена в дизайне API.

  - Согласованность с архитектурой Безопасной ОС: <br>
    Интерфейс мог бы быть оптимально интегрирован
    с микроядерной архитектурой Secure OS
    и её handle-based моделью безопасности.

  - Контролируемый объём работ: <br>
    такой подход позволяет сфокусировать усилия
    на реализации ключевых функций TEE
    и их взаимодействии с World Guard.

   Основной проблемой этого подхода является
   обеспечение соответствия стандартам,
   даже для подмножества функций,
   и предоставление достаточной функциональности
   для создания значимых TA.

   #### 3.1.1.4. Экспериментальные и исследовательские прототипы

   В академическом и исследовательском сообществе
   существуют различные архитектуры TEE
   и механизмы межмирового взаимодействия,
   часто фокусируясь на новых аппаратных возможностях
   или специфических свойствах безопасности.
   Некоторые прототипы исследуют собственные механизмы RPC,
   отличающиеся модели разделения памяти
   или совершенно новые парадигмы API,
   отличные от GlobalPlatform.

   Хотя такие исследовательские прототипы
   предлагают ценные идеи для потенциальных улучшений TEE
   и специализированных решений безопасности,
   им часто не хватает стандартизации
   и широкой поддержки со стороны экосистемы,
   что критично для разработки переносимых TA.

   Внедрение полностью экспериментального API
   отклонилось бы от признанных в индустрии стандартов,
   повысило бы порог вхождения для потенциальных разработчиков
   и ограничило бы совместимость.

   #### 3.1.1.5. Обоснование выбора подмножества API на базе GlobalPlatform

   После оценки альтернатив было принято решение
   использовать тщательно подобранное подмножество
   GlobalPlatform TEE Internal Core API
   для межмирового взаимодействия.
   Этот подход призван сбалансировать стремление
   к стандартизации со специфическими требованиями
   и ограничениями проекта.

   Выбор стоится на следущих причинах:

  - Стандартизация и привычность: <br>
    Спецификации GlobalPlatform TEE Internal Core API
    предоставляют хорошо определённый,
    признанный в индустрии стандарт
    для взаимодействия между клиентом TEE и TA.
    Использование подмножества этого стандарта
    позволяет опереться на существующую базу знаний,
    облегчая разработчикам TA,
    знакомым с концепциями TEE,
    понимание и использование системы.

  - Ключевая функциональность: <br>
    GP TEE API определяет такие основополагающие концепции,
    как контексты, сессии, разделяемая память и вызов команд,
    которые являются фундаментальными
    для большинства взаимодействий с TEE.
    Реализация подмножества, содержащего эти ключевые элементы,
    обеспечивает достаточную функциональность
    для широкого круга Доверенных Приложений.

  - Уменьшение трудоёмкости реализации и ДКБ: <br>
    Выбирая только необходимые вызовы API,
    значительно снижается сложность реализации
    в Secure OS по сравнению с полной имплементацией GP.
    Это способствует уменьшению TCB,
    что критично для безопасности.

  - Возможность будущего расширения: <br>
    Начиная с минимального подмножества,
    фреймворк GP предлагает чёткий путь
    для потенциальных будущих расширений,
    если потребуется больше функций.
    Модульная природа спецификаций GP
    позволяет добавлять функциональность постепенно.

   Выбранное подмножество включает функции:
    - TEEC_InitializeContext
    - TEEC_FinalizeContext
    - TEEC_OpenSession
    - TEEC_CloseSession
    - TEEC_InvokeCommand
    - TEEC_AllocateSharedMemory
    - TEEC_ReleaseSharedMemory

   Обеспечивая базовые компоненты
   для безопасного взаимодействия и вычислений,
   минимизируя при этом интерфейс,
   предоставляемый Secure OS.

 ## 3.2. Обзор архитектуры системы

  ### 3.2.1. Высокоуровневая архитектура

   #### 3.2.1.1. Архитектурные уровни

   Архитектура системы имеет четкую уровневую структуру,
   где каждый уровень выполняет специфические функции
   и работает на своем уровне привилегий.
   В основе системы лежит аппаратная платформа RISC-V,
   инициализацию которой осуществляет OpenSBI
   (Open Supervisor Binary Interface),
   выполняющий функции SEE.
   OpenSBI предоставляет необходимую
   низкоуровневую аппаратную абстракцию,
   выполняет начальную конфигурацию безопасности
   и управляет процессом передачи
   управления операционным системам.

   Над уровнем встроенного ПО функционирует
   Secure OS, работающая в выделенном
   безопасном мире (Secure World).
   Эта функциональность обеспечивается
   расширением RISC-V World Guard.
   Данное микроядро разработано
   с минимальной TCB.
   Его основные задачи включают
   изолированное выполнение доверенных приложений,
   управление защищенными ресурсами и
   принудительное применение политик безопасности системы.

   Параллельно, в отдельном домене,
   работает ОС нормального мира -
   это полнофункциональная операционная система.
   Она предоставляет среду для выполнения приложений
   общего назначения и взаимодействия с пользователем.

   #### 3.2.1.2. Обзор безопасного и нормального миров

   Система использует статическое распределение
   ресурсов центрального процессора
   для поддержания строгого разделения
   между доменами безопасности. Secure OS
   постоянно находится в памяти
   и исполняется исключительно на
   первом ядре ЦП.
   Это ядро полностью выделено
   для выполнения защищенных операций и доверенных приложений.

   Все остальные ядра ЦП отводятся нормальному миру,
   в котором функционирует операционная система Linux.
   Нормальный мир предоставляет многофункциональную
   среду для вычислений общего назначения,
   однако с точки зрения
   безопасного ира он считается недоверенным.

   Основные роли и обязанности четко разграничены:

  1. Безопасный мир (Secure OS):
   - Предоставляет изолированную среду исполнения
     для доверенных приложений.
   - Управляет защищенными системными ресурсами,
     такими как аппаратное обеспечение
     или защищенные области памяти.
   - Применяет capability-based модель безопасности к TA.
   - Обрабатывает критически важные операции
     и сервисы, запрашиваемые
     нормальным миром через
     строго определенный интерфейс.

  2. Нормальный мир (Linux):
   - Выполняет приложения общего назначения
     и управляет недоверенными системными ресурсами.
   - Взаимодействует с безопасным миром
     исключительно через предопределенный интерфейс
     для запроса к защищенным сервисам.
   - Не имеет прямого доступа к памяти или ресурсам,
     принадлежащим безопасному миру,
     если это явно не разрешено и не опосредовано Secure OS.

   Контроль соблюдения границ обеспечивается
   комбинацией аппаратных и программных механизмов:

  - Аппаратное расширение RISC-V World Guard
    обеспечивает принудительную изоляцию
    на аппаратном уровне,
    предотвращая прямой доступ нормального мира
    к областям памяти или периферийным устройствам,
    назначенным безопасному миру.

  - Обмен данными между мирами (inter-world communication)
    строго контролируется через
    специализированные очереди в разделяемой памяти
    (для запросов и ответов)
    и межпроцессорные прерывания (IPI)
    для сигнализации. Этот контролируемый канал
    гарантирует, что все взаимодействия
    могут быть проверены.

  ### 3.2.2. Ключевые компоненты системы

   #### 3.2.2.1. Ядро, менеджеры ресурсов и сервисы TEE

   Архитектура Secure OS построена на базе микроядра,
   исполняющегося на выделенном для него процессорном ядре.
   Микроядро предоставляет базовые сервисы,
   необходимые для функционирования Доверенной Среды Исполнения.
   К ним относятся безопасное переключение контекста
   между Доверенными Приложениями и внутренними задачами ядра,
   обработка прерываний, специфичных для Защищенного Мира,
   а также реализация механизмов capability-based модели безопасности.
   Микроядро отвечает за управление
   низкоуровневыми аппаратными ресурсами,
   выделенными для Защищенного Мира.

   Поверх микроядра функционируют несколько ключевых менеджеров ресурсов:

  - Менеджер задач (Task Manager): <br>
    Контролирует жизненный цикл TA
    и внутренних задач Защищенной ОС.
    Он отвечает за их создание
    (инициируемое Корневой Задачей (Root Task)
    по запросам из Обычного Мира),
    планирование и завершение.
    Каждое ДП, а также другие управляемые сущности,
    такие как потоки (threads),
    представляются в виде объектов ядра,
    доступ к которым и управление которыми
    осуществляется через дескрипторы
    в соответствии с capability-based моделью.

  - Менеджер памяти: <br>
    Управляет выделением, освобождением
    и защитой памяти в пределах Защищенного Мира.
    Это включает память для самого ядра,
    для отдельных ДП и для буферов,
    используемых при межмировом взаимодействии.
    Он использует базовые аппаратные механизмы,
    такие как PMP совместно с расширением World Guard,
    для обеспечения строгой изоляции памяти
    между различными ДП,
    а также между Защищенным и Обычным Мирами.
    Ресурсы памяти управляются как
    Объекты Виртуальной Памяти (VMO),
    доступ к которым также осуществляется через дескрипторы.

  - Менеджер IPC (Inter-Process Communication Manager): <br>
    Обеспечивает безопасные каналы взаимодействия
    внутри Защищенного Мира,
    например, между различными ДП или между ДП
    и сервисами Защищенной ОС.
    Это достигается с использованием объектов ядра,
    таких как каналы, где доступ и операции
    контролируются через capability,
    представленные дескрипторами.
    Менеджер IPC также поддерживает Root task
    в ее роли по ретрансляции
    сообщений в Обычный Мир и из него.

   Сервисы TEE реализованы поверх ядра
   и менеджеров ресурсов.
   Сервисы предоставляют функциональность
   Защищенной ОС для ДП через определенный API,
   определяемый самими сервисами.
   Сервисы включают управление сессиями ДП,
   обработку вызовов команд из Обычного Мира
   и управление криптографическими операциями.

   #### 3.2.2.2. Разделяемая память и взаимодействие на основе IPI

   Взаимодействие между Обычным Миром (Linux)
   и Защищенной ОС опирается на два основных механизма:
   разделяемую память и Межпроцессорные Прерывания.

   Основу для обмена данными составляют
   две предварительно выделенные страницы физической памяти.
   Одна страница предназначена для очереди запросов
   (Request Queue), позволяя Обычному Миру
   помещать в нее запросы для Защищенной ОС.
   Вторая страница служит очередью ответов
   (Response Queue), через которую
   Защищенная ОС передает результаты
   и уведомления обратно в Обычный Мир.
   Эти очереди реализуются как lock-free
   обеспечения эффективной передачи данных
   и снижения конкуренции за доступ.

   Доступ к этим областям разделяемой памяти
   осуществляется только в соответствии с
   заданной системной политикой безопасности:
   Обычный Мир имеет право записи в очередь запросов,
   из которой читает Защищенная ОС,
   а Защищенная ОС - право записи в очередь ответов,
   из которой читает Обычный Мир.

   Стандартные для RISC-V (IPI) используются
   в качестве механизма сигнализации
   для уведомления другой стороны о наличии сообщений
   в разделяемых очередях.

  - Сигнализация из Обычного Мира в Защищенный: <br>
    Когда Linux (работающий на ядре Обычного Мира)
    помещает новый запрос в разделяемую очередь запросов,
    он затем отправляет IPI на выделенное ядро
    Защищенного Мира (CPU0),
    уведомляя Защищенную ОС
    о доступности нового запроса для обработки.

  - Сигнализация из Защищенного Мира в Обычный: <br>
    После того как Защищенная ОС обработала запрос
    и поместила ответ в разделяемую очередь ответов,
    она не отправляет IPI, обратная передача запроса
    реализована на базе поллинга со стороны Linux драйвера.

   Такое сочетание явно определенных
   областей разделяемой памяти для передачи данных
   и IPI для нотификации о событиях
   формирует надежный и эффективный канал связи.

  ### 3.2.3. Схема распределения памяти и адресация

   #### 3.2.3.1. Физическая и виртуальная адресация

   Secure OS формирует и обслуживает свой собственный,
   отдельный набор таблиц страниц,
   который управляет трансляцией виртуальных адресов
   в физические в пределах Безопасного Мира.
   В процессе инициализации Secure OS настраивает регистр SATP
   (Supervisor Address Translation and Protection)
   для выделенного безопасного процессорного ядра
   таким образом, чтобы он указывал на ее корневую таблицу страниц.
   Это активирует виртуальную адресацию для ядра Secure OS,
   Доверенных Приложений и любых защищенных периферийных устройств,
   назначенных Безопасному Миру.

   Каждое ДП работает в своем собственном
   изолированном виртуальном адресном пространстве,
   управляемом Secure OS. Это гарантирует,
   что ДП не могут напрямую обращаться к памяти друг друга
   или к памяти ядра, если это явно не разрешено через мандаты
   объектов разделяемой памяти.

   Физическая память секционируется ОС
   с использованием расширения World Guard.
   Определенные области физической памяти назначаются
   для эксклюзивного использования Безопасным Миром,
   другие выделяются Нормальному Миру,
   а некоторые, специально ограниченные области,
   определяются как разделяемые.

   Следовательно, отображения памяти в Безопасном Мире
   (устанавливаемые Secure OS) предоставляют доступ
   к защищенным областям физической памяти,
   которые невидимы, для конфигурации MMU из Нормального Мира.
   MMU Нормального Мира функционирует независимо
   на других процессорных ядрах под управлением Linux.

   #### 3.2.3.2. Механизмы изоляции

   Основным аппаратным механизмом обеспечения
   изоляции памяти между Безопасным и Нормальным Мирами
   является расширение RISC-V World Guard.
   World Guard связывает идентификатор мира (world ID)
   с транзакциями памяти, исходящими от процессорных ядер,
   и с обращениями к периферийным устройствам.

   Secure OS в процессе своей загрузки
   и при дальнейшей работе на выделенном безопасном ядре
   конфигурирует аппаратные контроллеры World Guard.
   Эти контроллеры программируются набором правил,
   которые определяют,
   какие области физической памяти и периферийные устройства
   доступны для какого идентификатора мира.

   Например, страницы памяти, выделенные для ядра Secure OS,
   Доверенных Приложений и приватных данных Безопасного Мира,
   конфигурируются таким образом,
   чтобы быть доступными только в том случае,
   если транзакция исходит от процессорного ядра,
   работающего в Безопасном Мире
   (т.е. обладающего идентификатором Безопасного Мира).

   Если операционная система Нормального Мира,
   функционирующая на других ядрах
   с идентификатором Нормального Мира,
   попытается получить доступ
   к странице физической памяти,
   эксклюзивно назначенной Безопасному Миру,
   аппаратные контроллеры World Guard
   обнаружат это нарушение политики.
   Подобные попытки несанкционированного доступа
   приводят к аппаратному исключению,
   которая обрабатывается в соответствии с конфигурацией
   механизма сообщений об ошибках World Guard.
   Это эффективно предотвращает прямое чтение,
   запись или исполнение кода Нормальным Миром
   в пределах защищенных страниц Безопасного Мира.

   #### 3.2.3.3. Очереди в разделяемой памяти

   Взаимодействие между Безопасным и Нормальным Мирами
   осуществляется через зарезервированные
   области физической памяти,
   сконфигурированные как разделяемые буферы.
   В частности, используются две выделенные
   страницы физической памяти,
   выровненные по границе размера страницы:
   одна для запросов от Нормального Мира к Безопасной ОС
   (очередь запросов), а другая — для ответов от Безопасной ОС
   обратно в Нормальный Мир (очередь ответов).

   Безопасная ОС, совместно с
   конфигурациями контроллеров World Guard,
   предоставляет обоим мирам соответствующие права доступа
   к этим специальным разделяемым страницам.

   Данные очереди реализованы в виде lock-free кольцевых буферов,
   что позволяет управлять конкурентным доступом
   без накладных расходов,
   свойственных традиционным механизмам блокировок.
   Использование lock-free алгоритмов минимизирует
   уровень конкуренции за ресурсы и сокращает задержки,
   особенно с учетом того, что Нормальный Мир
   может помещать запросы в очередь из различных
   контекстов исполнения
   (хотя они и обрабатываются последовательно
   одноядерной Безопасной ОС).

   Фиксированный размер и заранее определенное
   расположение этих очередей упрощают
   управление памятью для межмирового обмена данными.

  ### 3.2.4. Процесс исполнения Безопасной ОС

   #### 3.2.4.1. Обзор процесса загрузки Secure OS

   Процесс загрузки начинается с OpenSBI,
   который выполняет начальную настройку платформы.
   OpenSBI идентифицирует и загружает Безопасную ОС,
   передавая ей управление на выделенном первом ядре ЦП (ядре 0).
   Затем Безопасная ОС инициализирует свои ключевые компоненты,
   включая подсистему управления памятью
   и настраивает расширение World Guard для изоляции ядра 0
   в качестве Безопасного Мира.

   Это включает настройку контроллеров WorldGuard
   для защиты памяти Безопасного Мира.
   После своей инициализации Secure OS возвращается обратно OpenSBI.
   После этого OpenSBI приступает к загрузке
   ОС Обычного Мира (Linux) на остальных ядрах ЦП.
   Эти ядра настраиваются OpenSBI

   #### 3.2.4.2. Переходы между мирами

   Переходы исполнения между
   Безопасным и Обычным Мирами строго контролируются.
   Когда Обычному Миру (Linux) необходимо вызвать
   сервис из Безопасной ОС, он подготавливает запрос
   в выделенной очереди запросов в разделяемой памяти,
   а затем, инициирует межпроцессорное прерывание (IPI)
   на ядро 0. Это IPI служит сигналом
   для Безопасной ОС о необходимости проверить очередь запросов.

   Безопасная ОС обрабатывает запрос и помещает ответ
   в очередь ответов в разделяемой памяти.
   Обычный Мир, опрашивает очередь ответов для получения результата.

   Перед обработкой любого запроса из Обычного Мира
   Безопасная ОС выполняет проверки достоверности
   на основе содержимого и источника сообщения.
   Сохранность состояния Безопасного Мира
   во время переходов обеспечивается расширением World Guard,
   которое управляет аппаратным контекстом для текущего мира,
   исполняющегося на ядре.
   Безопасная ОС отвечает за сохранение
   и восстановление контекстов конкретных
   Доверенных Приложений (TA) в Безопасном Мире,
   если под её управлением находится несколько TA или сервисов.

   #### 3.2.4.3. Планирование в Безопасной ОС

   Безопасная ОС функционирует
   на единственном выделенном ядре ЦП (ядре 0)
   и использует однопроцессорную стратегию планирования
   для управления своими внутренними задачами
   и любыми размещаемыми ею Доверенными Приложениями (TA).

   Реализована вытесняющая, round-robin политика
   планирования для обеспечения справедливого доступа
   к ЦП для всех готовых к выполнению сущностей в Безопасном Мире.
   Переключение контекста в Безопасной ОС
   включает сохранение контекста исполнения
   (регистров, указателя стека, счетчика команд)
   текущей TA или сервиса и восстановление контекста
   следующей запланированной сущности.

   Учитывая, что Безопасная ОС и её TA исполняются
   исключительно на ядре 0,
   их деятельность по планированию полностью независима
   и не конфликтует с планировщиком ядра Linux,
   который управляет задачами на других ядрах ЦП,
   работающих в Обычном Мире.
   Архитектура нацелена на то,
   чтобы операции Безопасней ОС были
   относительно кратковременными для
   обеспечения своевременных ответов
   Доверенным Приложениям и запросам из Обычного Мира.

  ### 3.2.5. Обеспечение безопасности и реализация политик

   #### 3.2.5.1. Модель безопасности

   Безопасная ОС применяет многоуровневый подход
   к обеспечению безопасности и реализации политик,
   сочетая механизмы изоляции на аппаратном уровне,
   предоставляемые расширением RISC-V World Guard,
   с программно-определяемой моделью
   гранулярного контроля доступа.
   Такой подход гарантирует защиту как
   Безопасного Мира, так и работающих в нем
   Доверенных Приложений от недоверенного
   Нормального Мира, и, что особенно важно,
   друг от друга, в соответствии с
   принципом наименьших привилегий.

   В Безопасной ОС реализована мандатно-дискреционная модель безопасности,
   где доступ ко всем системным ресурсам
   и сервисам ядра опосредован через дескрипторы,
   или же хендлы (handles).

   Дескриптор выступает в роли неподделываемого токена,
   представляющего определенное полномочие (capability) -
   право на выполнение заданного набора операций
   над связанным объектом ядра
   (например, областями памяти,
   каналами связи, блоками управления задачами).
   Эта модель отличается от традиционного
   контроля доступа,
   фокусируясь на конкретных разрешениях,
   привязанных к экземплярам объектов,
   а не на общих привилегиях пользователя.

   Изначально Доверенные Приложения
   получают набор дескрипторов
   через предопределенный Манифест,
   предоставляемый root таской системы
   при запуске ДП.
   Новые объекты и, соответственно,
   новые дескрипторы с конкретными полномочиями,
   создаются путем вызова методов объекта-фабрики,
   для чего ДП также должно обладать соответствующим дескриптором.

   Операции над этими объектами
   запрашиваются через безопасные системные вызовы
   (secure syscalls),
   которые являются основным интерфейсом между ДП и ядром.
   Предъявляя дескриптор при системном вызове,
   ДП неявно подтверждает свое право
   на выполнение запрошенной операции.
   Этот механизм обеспечивает детальный контроль доступа,
   поскольку каждый дескриптор явно определяет
   допустимые взаимодействия с соответствующим ему объектом.

   Центральное место в этой модели занимает
   контроль соблюдения разрешений на этапе выполнения.
   При вызове системного вызова
   ядро выполняет строгую проверку.
   Сначала оно проверяет аутентичность
   и валидность предъявленного дескриптора,
   убеждаясь, что он соответствует
   активному объекту ядра и может использоваться
   вызывающим ДП в его текущем контексте.
   Затем ядро проверяет, позволяет ли полномочие,
   инкапсулированное в дескрипторе,
   выполнить запрошенную операцию над целевым объектом.
   Если полномочия недостаточны или дескриптор недействителен,
   операция отклоняется, и ДП получает сообщение об ошибке.
   Такая проверка при каждой операции критически важна
   для предотвращения подделки полномочий ДП
   или эскалации привилегий сверх явно предоставленных.
   Поскольку ДП не могут напрямую манипулировать
   содержимым дескрипторов или произвольно создавать
   новые полномочия, они ограничены теми правами,
   которые были им предоставлены через первоначальный Манифест
   или законно получены от объекта-фабрики,
   что надежно обеспечивает соблюдение
   принципа наименьших привилегий.

   #### 3.2.5.2. Интеграция с World Guard

   Программно-определяемая мандатно-дискреционная
   модель безопасности Безопасной ОС
   дополняет аппаратную изоляцию,
   обеспечивая детальный контроль доступа
   внутри Безопасного Мира.

   В то время как World Guard предотвращает
   несанкционированный доступ Нормального Мира
   к ресурсам Безопасного Мира
   и вмешательство в его работу,
   мандатно-дискреционная модель тщательно регулирует
   взаимодействие ДП и компонентов Безопасной ОС
   с объектами и ресурсами, управляемыми ядром.

   Такой многоуровневый подход создает стратегию
   эшелонированной обороны (defense-in-depth):
   World Guard устанавливает надежный межмировой периметр,
   а мандатно-дискреционная система обеспечивает
   строгую компартментализацию и соблюдение политик
   внутри этого периметра.

   Когда аппаратный контроллер (checker) WorldGuard
   обнаруживает попытку несанкционированного
   доступа к памяти (например, код из NW
   пытается прочитать приватную память SW,
   или же наоборот)
   или недействительный переход между мирами
   (например, некорректная инструкция
   пытается незаконно изменить текущее состояние
   мира для данного ядра),
   он генерирует аппаратное исключение (fault).
   Реакция системы на такое событие определяется обработчиками,
   сконфигурированными Безопасной ОС.

   Нарушения, исходящие из Нормального Мира,
   приводят к прерыванию на ядре Нормального Мира,
   вызвавшем нарушение. Специфическая обработка
   (например, сигнализация об ошибке ядру Linux)
   позволяет Нормальному Миру управлять сбоем
   в своем собственном контексте,
   не компрометируя Безопасный Мир.

   Если программный компонент внутри самого
   Безопасного Мира спровоцирует нарушение World Guard
   это также приведет к прерыванию,
   обрабатываемому Безопасной ОС,
   что вызоыет завершение сбойного ДП или сервиса,
   или контролируемую остановку системы,
   если нарушение произошло из ядра Secure OS.

   Таким образом, World Guard выступает как
   механизм принудительного применения
   политики разделения миров,
   с определенными путями обработки сбоев
   при нарушениях этих аппаратно-обеспечиваемых правил.
   Механизмы сообщения об ошибках гарантируют,
   что такие нарушения могут быть зарегистрированы.

  ### 3.2.6 Жизненный цикл доверенных приложений

   #### Создание TA

   Жизненный цикл Доверенного Приложения (ДП)
   в Безопасной ОС инициируется поступлением запроса
   TEEC_OpenSession из Обычного Мира.
   Обработкой данного запроса занимается Root Task,
   ответственная за управление созданием экземпляров ДП.

   Процесс создания ДП включает несколько этапов,
   координируемых Корневой Задачей
   совместно с основными службами Безопасной ОС:

  1. Загрузка образа ДП: <br>
     Безопасная ОС загружает двоичный образ ДП
     (ELF-файла, указанный в предопределенном манифесте
     и размещенный в файловой системе Secure OS)
     в выделенное, изолированное адресное пространство.
     Это включает синтаксический анализ исполняемого формата
     и отображение его сегментов кода,
     данных и BSS в виртуальное адресное пространство ДП.

  2. Выделение памяти: <br>
     Специализированные области памяти выделяются для стека,
     кучи и приватных данных ДП.
     Эта память защищена и изолирована от других ДП
     и самого ядра Безопасной ОС
     с использованием таких механизмов, как PMP и MMU.

  3. Инициализация дескрипторов: <br>
     На основе манифеста ДП Корневая Задача
     предоставляет доверенному приложению
     начальный набор дескрипторов.

  4. Создание процесса/потока: <br>
     В рамках Безопасной ОС для размещения ДП
     создается новая структура процесса (task).
     В этом процессе порождается начальный поток,
     с точкой входа,
     установленной на соответствующую стартовую
     процедуру ДП (TA_CreateEntryPoint).

  5. Начальное состояние: <br>
     После успешного создания и инициализации процесс
     ДП переводится в состояние,
     в котором он уже выполнил свою процедуру
     TA_CreateEntryPoint,
     провел необходимую самоинициализацию
     и готов к приему команд, но изначально неактивен.

   Вызов TEEC_OpenSession возвращает идентификатор сессии
   клиенту в Обычном Мире
   в случае успешного создания ДП
   и установления сессии.
   Этот идентификатор сессии используется
   для последующих взаимодействий с данным экземпляром ДП.

   #### Исполнение TA

   После того как сессия с ДП успешно установлена
   (через TEEC_OpenSession) и его процедура
   TA_CreateEntryPoint завершила свою работу,
   ДП переходит в состояние ожидания
   и уступает управление планировщику Безопасной ОС.
   TA остается неактивной, ожидая конкретных команд из Обычного Мира.

   Дальнейшее взаимодействие осуществляется
   через вызовы TEEC_InvokeCommand,
   поступающие от клиента из Обычного Мира.
   При поступлении такого вызова
   происходит слудующая последовательность действий:

  1. Активация и диспетчеризация: <br>
     Root task получает запрос InvokeCommand.
     Она идентифицирует целевую сессию ДП
     и конкретный идентификатор исполняемой команды
     (ID метода).
     После этого поток ДП активируется
     (ставится в очередь на исполнение).

  2. Передача аргументов: <br>
     Параметры, связанные с InvokeCommand,
     включая идентификатор команды
     и любые буферы ввода/вывода,
     становятся доступными ДП.
     Безопасная ОС гарантирует,
     что ДП получает эти аргументы безопасным
     и определённым образом, через его контекст
     исполнения или заранее подготовленные участки памяти.

  3. Исполнение ДП: <br>
     ДП исполняет свою функцию
     TA_InvokeCommandEntryPoint.
     На основе полученного идентификатора команды
     ДП выполняет запрошенное вычисление.
     Это может включать:
    - Доступ к своим приватным данным и ресурсам.
    - Использование предоставленных ему дескрипторов
      для взаимодействия со службами Безопасной ОС
      (например, криптографическими операциями).
    - Обмен данными с другими ДП или Root task
      через защищённые каналы
      межпроцессного взаимодействия (IPC),
      используя дескрипторы,
      полученные при создании.
    - Запрос на выделение новых областей разделяемой памяти,
      если команда требует обмена большими объемами данных
      с Обычным Миром. Вызов
      API TEEC_AllocateSharedMemory,
      инициированный клиентом Обычного Мира,
      может быть связан с потребностями в памяти,
      выявленными во время выполнения TEEC_InvokeCommand.
      Обмен данными затем осуществляется клиентом
      Обычного Мира и ДП путем записи и чтения
      из этой разделяемой памяти.

   По завершении выполнения команды ДП
   подготавливает любые результаты
   (в выходных буферах или путем
   модификации разделяемой памяти)
   и возвращает код состояния.
   Затем Безопасная ОС передаёт этот статус
   и любые релевантные данные обратно
   клиенту Обычного Мира в качестве ответа
   на TEEC_InvokeCommand.
   После этого ДП может снова уступить управление,
   ожидая дальнейших команд.

   #### Завершение работы TA

   Завершение работы экземпляра Доверенного Приложения
   и освобождение занимаемых им ресурсов инициируются,
   когда клиентское приложение Обычного Мира
   явным образом закрывает сессию с помощью вызова
   TEEC_CloseSession. Этот запрос сигнализирует о том,
   что сервисы ДП для данной конкретной сессии более не требуются.

   Процесс завершения включает следующие ключевые этапы,
   управляемые Безопасной ОС, при содействии
   и с уведомлением Корневой Задачи:

  1. Уведомление о закрытии сессии: <br>
     ДП уведомляется о закрытии своей сессии,
     путем вызова его функции TA_CloseSessionEntryPoint.
     Это позволяет ДП выполнить специфичную
     для сессии очистку,
     например, освободить ресурсы,
     выделенные конкретно для этой сессии.

  2. Уничтожение ДП: <br>
     Если с экземпляром ДП не связано других активных сессий
     (или если ДП предназначено для работы в режиме одной сессии),
     Безопасная ОС приступает к полному прекращению работы
     ДП путем вызова его функции TA_DestroyEntryPoint.
     Эта функция предоставляет ДП последнюю возможность
     выполнить глобальную очистку.

  3. Освобождение ресурсов:
     Освобождаются следующие типы ресурсов:
    - Освобождение объектов: <br>
      Все дескрипторы, принадлежащие ДП,
      аннулируются и освобождаются.
      На соответствующие объекты ядра,
      связанные с этими дескрипторами
      (например, объекты памяти, каналы связи)
      снимаются ссылки. Если ДП было
      последним держателем ссылки,
      сам объект удаляется соответствующим
      менеджером ресурсов Безопасной ОС.
    - Освобождение разделяемой памяти: <br>
      Любые области разделяемой памяти,
      явно выделенные для связи между
      данным экземпляром ДП и Обычным Миром
      (например, через TEEC_AllocateSharedMemory) освобождаются:
      отменяется их отображение (unmap) из адресного пространства
      ДП в Безопасном Мире и помечаются
      для последующего освобождения.
      Драйвер Linux на стороне Обычного Мира,
      как правило, также отвечает
      за отмену отображения этих регионов.
    - Освобождение приватной памяти: <br>
      Приватные области памяти,
      выделенные для кода, данных, стека и кучи ДП,
      возвращаются менеджеру памяти Безопасной ОС.
      Структура задачи/процесса ДП
      и связанные с ней потоки уничтожаются.

   После успешного выполнения этих шагов
   экземпляр ДП прекращает свое существование,
   а его ресурсы становятся доступными
   для повторного выделения.

   Код результата, указывающий на успех
   или неудачу операции TEEC_CloseSession,
   возвращается клиенту Обычного Мира.
   Безопасная ОС гарантирует,
   что процесс завершения работы является упорядоченным
   и не нарушает целостность Безопасного Мира
   или других активных ДП.

 ## 3.3. Интеграция WorldGuard

  ### 3.3.1 Конфигурирование WorldGuard

   #### 3.3.1.1 Конфигурация миров (двухмировая модель)

   Фундаментом архитектуры безопасности системы
   является разделение аппаратных
   и программных ресурсов на два принципиально различных мира:
   Защищённый мир и Обычный мир.
   Такое разделение реализуется с помощью расширения WorldGuard.

  - Разделение системных ресурсов: <br>
    Расширение WorldGuard обеспечивает фундаментальное
    разделение системных ресурсов.
    Физическая память разделяется на области,
    исключительно доступные Защищённому миру, области,
    исключительно доступные Обычному миру,
    и специальные, ограниченные области,
    выделенные под разделяемую память
    для межмирового взаимодействия. Одно ядро ЦП
    статически назначается Защищённому миру
    для выполнения Безопасной ОС
    и её Доверенных приложений.
    Все остальные ядра ЦП отводятся Обычному миру для работы Linux.

  - Обоснование двухмировой архитектуры: <br
    Такая двухмировая модель обеспечивает строгую,
    аппаратно усиленную изоляцию между
    доверенной средой (Защищённый мир)
    и средой общего назначения,
    потенциально подверженной компрометации (Обычный мир).
    Этот архитектурный выбор продиктован
    проверенными концепциями ДСИ
    и предлагает чёткое разделение окружений.
    Он упрощает Доверенную вычислительную базу,
    выделяя отдельный мир для критически важных
    с точки зрения безопасности операций,
    отделяя их от сложностей многофункциональной операционной среды.

  - Роли каждого мира:
    - Защищённый мир (ЗМ): <br>
      Работает с идентификатором мира 0 (WID 0).
      В нём размещается Безопасная ОС,
      отвечающая за выполнение Доверенных приложений,
      управление криптографическими ключами и другими секретами,
      выполнение чувствительных к безопасности вычислений
      и реализацию мандатной модели безопасности.
      Все операции в Защищённом мире рассматриваются
      как привилегированные с точки зрения безопасности.
    - Обычный мир (ОМ): <br>
      Работает с идентификатором мира 1 (WID 1).
      В нём размещаются Универсальная ОС (Linux) и её приложения.
      Обычный мир рассматривается Защищённым миром как недоверенный.
      Он взаимодействует с Защищённым миром
      только через строго определённый интерфейс,
      как правило, для запроса служб у ДП.

  - Назначение и управление идентификаторами миров (World ID): <br>
    WorldGuard связывает идентификатор мира (WID)
    с транзакциями, исходящими от ядер ЦП.
    В данной системе WID 0 назначается Защищённому миру,
    а WID 1 — Обычному миру.
    Назначение WID ядрам ЦП выполняется OpenSBI
    на ранних этапах загрузки,
    используя его привилегии M-режима.
    OpenSBI настраивает ядро ЦП 0 для работы с WID 0 (Защищённый мир)
    перед передачей управления Безопасной ОС.
    Остальные ядра ЦП настраиваются с WID 1 (Обычный мир)
    перед загрузкой на них Linux.
    Безопасная ОС, после инициализации и запуска
    в Защищённом мире на ядре 0,
    работает под WID 0. Она гарантирует,
    что её обращения к памяти и, следовательно,
    обращения управляемых ею ДП, корректно ассоциированы с этим WID.
    CSR-регистр mlwid (Machine Lower-privilege World ID)
    используется M-режимом (OpenSBI) для установки
    WID для S-режима (в котором работает Безопасная ОС).
    Это статическое назначение WID формирует
    основу аппаратной изоляции.

   #### 3.3.1.2 Конфигурирование контроллеров WorldGuard

   Контроллеры WorldGuard (также называемые чекерами) -
   это аппаратные блоки, интегрированные в коммутационную матрицу
   памяти системы. Они отслеживают транзакции памяти,
   сопоставляют WID инициатора с
   заранее запрограммированными правилами
   для областей памяти и принудительно применяют
   разрешения на доступ.
   Безопасная ОС отвечает за настройку этих контроллеров
   на этапе своей инициализации
   для установления и поддержания надёжной изоляции.

   Конфигурирование защищённой RAM с использованием слотов WG:
  - Подход к разделению защищённой памяти: <br>
    Физическое адресное пространство разделяется
    путём программирования слотов контроллера WorldGuard.
    Каждый слот определяет правило для конкретного диапазона памяти,
    связывая его с разрешениями для различных WID.
    Безопасная ОС выделяет отдельные регионы
    для собственного кода и данных ядра,
    приватной памяти каждого ДП
    и страниц разделяемой памяти,
    используемых для межмирового взаимодействия.
    Эти разделения транслируются
    в правила для слотов контроллера WG.
    Такое разделение статично
    и устанавливается во время загрузки.

  - Блокировка регионов памяти для Защищённого мира: <br>
    Области памяти, предназначенные
    для эксклюзивного использования Защищённым миром
    (например, образ Безопасной ОС, приватные стеки и кучи ДП),
    настраиваются в слотах контроллера WG.
    Эти слоты указывают, что только транзакции,
    инициированные WID 0 (Защищённый мир),
    имеют разрешение на доступ для чтения и/или записи.
    Любая попытка доступа к этим регионам со стороны
    WID 1 (Обычный мир) перехватывается контроллером WG,
    что приводит к исключению.
    Для обеспечения неизменности этих критически
    важных конфигураций безопасности бит L
    (lock - блокировка) в конфигурационном регистре (cfg)
    каждого слота контроллера WG устанавливается
    Безопасной ОС после инициализации.
    После блокировки конфигурация слота
    не может быть изменена до следующего
    аппаратного сброса системы.

  - Установка границ разделов: <br>
    Основной раздел, принудительно
    устанавливаемый WorldGuard -
    это раздел между Защищённым и Обычным мирами.
    Эта граница определяется совокупностью правил,
    запрограммированных в слотах контроллера WG.
    - Память Обычного мира: <br>
      Регионы, предназначенные для использования
      Обычным миром (например, основная RAM для Linux),
      настраиваются так, чтобы разрешать чтение/запись
      для WID 1 и запрещать доступ для WID 0.
      Это предотвращает непреднамеренный
      или злонамеренный доступ Защищённого мира
      к приватным данным Обычного мира,
      следуя принципу наименьших привилегий.
    - Регионы разделяемой памяти: <br>
      Для межмирового взаимодействия определённые страницы
      (например, для очередей запросов и ответов)
      настраиваются в слотах WG так,
      чтобы быть доступными как для WID 0,
      так и для WID 1.
      Однако разрешения могут быть асимметричными:
      для очереди запросов WID 1 может иметь право на запись,
      тогда как WID 0 (ЗМ) - право на чтение,
      и наоборот для очереди ответов.
    - Политика контроля доступа: Политика достаточно прямолинейна:
      - Доступ из REE к приватной памяти TEE
        строго запрещён (чтение, запись, выполнение).
      - Доступ из TEE к приватной памяти REE,
        запрещён для поддержания изоляции
        и предотвращения превращения TEE
        в вектор атак на REE.
      - Доступ к разделяемой памяти
        явно разрешён с тщательно определёнными правами.

  - Интеграция атрибутов памяти (чтение/запись/выполнение)
    с проверками WorldGuard:
    - Контроллеры WorldGuard в основном обеспечивают
      соблюдение разрешений на основе
      типов доступа "чтение" и "запись" для указанных WID
      в определённых диапазонах памяти.
      Поле perm в каждом слоте контроллера
      напрямую кодирует эти разрешения R/W
      для каждого мира.
      Нарушение этих разрешений немедленно
      вызывает исключение, регистрируемый контроллером.
    - Выборка инструкций ядром ЦП рассматривается
      шинной структурой и, следовательно,
      контроллерами WorldGuard как операция чтения из памяти.
      Если WID лишён права на чтение определённой области
      памяти контроллером WG, ему также будет
      неявно отказано в праве на выборку
      инструкций (выполнение) из этой области на уровне WorldGuard.
    - Более гранулярные разрешения на выполнение
      (например, биты NX для страниц данных) внутри мира
      управляются Модулем Управления Памятью (MMU) этого мира.
      Например, Безопасная ОС использует свой MMU
      (настраиваемый через записи в таблицах страниц, PTE)
      для маркировки своих страниц данных как неисполняемых для ДП,
      даже если WorldGuard разрешает WID 0 читать эти страницы.
      Таким образом, WorldGuard обеспечивает крупнозернистую
      межмировую изоляцию тогда как MMU
      предоставляет более мелкозернистую
      внутримировую защиту и управление виртуальной памятью.

  ### 3.3.2. Интеграция доверенной операционной системы

   #### 3.3.2.1 Информирование об ошибках

   Интеграция с Защищённой Операционной Системой
   в части обработки ошибок расширения WorldGuard
   включает немедленное обнаружение проблем.
   Аппаратные контроллеры WorldGuard выявляют
   попытки несанкционированного доступа
   или ошибки конфигурации,
   записывая в свои регистры errcause и erraddr
   подробности инцидента,
   такие как идентификатор мира-нарушителя (WID),
   тип доступа (чтение/запись) и целевой физический адрес.

   При обнаружении нарушения,
   относящегося к домену Защищённого Мира или его ресурсам:

  1. Обнаружение и уведомление о нарушении: <br>
     Контроллер WorldGuard настроен
     с установленными битами IR (прерывание при чтении)
     и IW (прерывание при записи) для областей памяти.
     Нарушение инициирует соответствующую реакцию.
     Прерывание, если будет направлено в Secure OS.
     Обработчик прерываний затем опрашивает регистры
     errcause и erraddr контроллера WorldGuard
     (доступные через отображение в память)
     для получения информации о сбое.

  2. Структура информирования: <br>
     Secure OS логгирует информацию о нарушении в консоль
     через UART драйвер:
     - Временная метка события.
     - Содержимое errcause: WID нарушителя,
       тип доступа (чтение/запись),
       был ли сигнализирован контроллером
       сбой шины (be) или прерывание (ip).
     - Содержимое erraddr:
       физический адрес попытки доступа.
     - Идентификатор компонента ЗОС или
       контекста Доверенного Приложения,
       если сбой произошёл внутри Защищённого
       Мира и его источник может быть надёжно определён.
  3. Стратегии реагирования:
     - Нарушения со стороны Обычного Мира (ОМ):
       Если WID нарушителя указывает на попытку
       Обычного Мира получить несанкционированный доступ
       к памяти Защищённого Мира (ЗМ),
       CPU 0 ну будет проинформирован об этом, и со стороны
       Secure OS никаких действий произведено не будетб,
       поскольку нормальный мир сам отвечает
       за обработку сбоев на своих ядрах.
       Основное противодействие осуществляется аппаратными
       средствами WorldGuard, блокирующими доступ.
     - Нарушения со стороны ДП: <br>
       Если ДП внутри Защищённого Мира инициирует
       нарушение WorldGuard (например, пытаясь
       получить доступ к памяти за пределами
       разрешённых ему областей). Secure OS в этом случае:
       - Регистрирует критическую ошибку.
       - Немедленно завершает работу ДП-нарушителя
         для предотвращения дальнейшей
         компрометации или нестабильности.
       - Высвобождает ресурсы, удерживаемые ДП.
       - Сообщает об ошибке клиенту Обычного Мира,
         у которого была активная сессия с этим ДП.
     - Нарушения со стороны ядра Защищённой ОС: <br>
       Если нарушение WorldGuard связано с самим ядром Secure OS,
       это указывает на серьёзную внутреннюю
       несогласованность или ошибку. В этом случае Secue OS:
       - Попытается зарегистрировать диагностическую
         информацию, если это возможно.
       - Переходит в контролируемое состояние паники,
         прекращая дальнейшие операции
         в Защищённом Мире для предотвращения
         потенциального распространения небезопасного состояния.

   #### 3.3.2.2 Управление переходами между мирами

   В реализованной двухмировой модели с WorldGuard,
   где Защищённая ОС статически привязана
   к ядру 0, а Linux - к остальным ядрам,
   под переходами между мирами в первую очередь
   понимается контролируемое взаимодействие
   и потоки сигналов между этими
   статически разделёнными средами исполнения,
   а не динамические изменения WID на одном ядре для обычных вызовов.

  1. Направление передачи данных ОМ -> ЗМ:
     -  Драйвер Linux, подготавливает сообщение-запрос
        и помещает его в общую очередь запросов.
      - Затем Обычный Мир инициирует
        Межпроцессорное Прерывание (МПП),
        нацеленное на ядро 0.
        Это делается через вызов SBI (sbi_send_ipi).
      - Защищённая ОС, работающая на ядре 0,
        получает это МПП. Её обработчик МПП,
        затем проверяет очередь запросов,
        извлекает сообщение и передаёт
        его соответствующему ДП или внутренней службе.
   2. Направление передачи данных ЗМ -> ОМ:
      - После обработки запроса Защищённая ОС
        или ДП помещает ответное сообщение в общую очередь ответов.
      - В текущей реализации ЗОС не отправляет МПП
        обратно в Обычный Мир.
        Вместо этого драйвер Linux в Обычном Мире использует
        механизм опроса через, выделенный поток ядра,
        который периодически проверяет очередь ответов
        на наличие готовых сообщений.
   3. Обработка прерываний:
      - Основной переход, инициируемый прерыванием, -
        это МПП из ОМ в ЗМ,
        сигнализирующее о новом запросе.
      - Исключения по вине WorldGuard настроены на генерацию
        прерываний для ядра 0, также являются формой события,
        которое ЗОС обрабатывает для управления нарушениями безопасности.

   #### 3.3.2.3 Страницы обмена данными

   1. Определение областей разделяемой памяти: <br>
      Предварительно определены две основные области
      разделяемой памяти, каждая состоит
      из одной физической страницы, выровненных по границе 4 КиБ:
      - Страница очереди запросов: <br>
        Используется Обычным Миром
        для отправки запросов в Защищённый Мир.
      - Страница очереди ответов: <br>
        Используется Защищённым Миром
        для отправки ответов обратно в Обычный Мир.

   2. Конфигурация WorldGuard для разделяемых страниц: <br>
      Во время своей инициализации Защищённая ОС
      программирует контроллер WorldGuard
      для принудительного применения прав доступа
      для этих страниц обмена данными:
      - Права доступа для страницы очереди запросов: <br>
        Конфигурируется слот в контроллере WorldGuard,
        соответствующий диапазону физических
        адресов очереди запросов.
        Поле perm для этого слота выставляется:
        - Обычный Мир (WID 1): <br>
          право на запись и, на чтение, т.к.
          реализация очереди на стороне ОМ
          этого требует для управления собственной
          метаинформацией.
        - Защищённый Мир (WID 0): право на чтение.
        - Права на выполнение запрещены для обоих миров.
      - Права доступа для страницы очереди ответов: <br>
        Конфигурируется слот,
        соответствующий диапазону
        физических адресов очереди ответов.
        Поле perm для этого слота выставляется:
        - Защищённый Мир (WID 0): <br>
          право на запись и на чтение
          для управления своей очередью.
        - Обычный Мир (WID 1): право на чтение.
        - Права на выполнение запрещены для обоих миров.

   3. Расположение и выравнивание: <br>
      Разделяемые области являются физически
      смежными и выровнены по границам страниц (4 КиБ),
      чтобы соответствовать гранулярности управления
      памятью и упростить конфигурацию правил WorldGuard.
      Для предотвращения случайных переполнений,
      которые могут повредить смежную память,
      ЗОС настраивает канареечные страницы
      (недоступные защитные страницы-маркеры)
      вокруг этих разделяемых страниц обмена данными,
      используя дополнительные правила WorldGuard.


 ## 3.4. Процесс безопасной загрузки и инициализации

  ### 3.4.1 Ранняя инициализация Безопасной ОС

   #### 3.4.1.1 Передача управления от OpenSBI

   OpenSBI, выступающий в роли среды исполнения
   уровня супервизора (Supervisor Execution Environment, SEE),
   инициирует процесс загрузки.
   OpenSBI загружает образ прошивки Безопасной ОС,
   указанный в FW_PAYLOAD_PATH,
   в физическую память на основном ядре процессора (hart 0),
   выделенном для выполнения безопасных операций.
   Затем управление передается точке входа Безопасной ОС -
   процедуре _start. OpenSBI передает Безопасной ОС
   ключевые системные параметры через регистры общего назначения:
   a0 содержит идентификатор
   загружаемого ядра (hart ID),
   а a1 - физический адрес дерева устройств
   (Flattened Device Tree, FDT).

   Процедура _start,
   реализованная в файле head.S,
   получает эти параметры и сохраняет
   их для последующего использования
   на более высоких уровнях инициализации на языке C,
   в частности, функцией early_boot,
   которая применяет FDT для конфигурации платформы.

   #### 3.4.1.2 Настройка стека и базовой схемы памяти

   Перед активацией MMU и созданием
   полноценной среды выполнения C,
   для ассемблерных подпрограмм и ранних вызовов функций
   C необходим начальный стек.
   Этот стек выделяется статически
   в образе памяти Безопасной ОС,
   а его размер определяется равным 6 физическим страницам.

   Процедура _start вычисляет виртуальный адрес
   вершины этого стека.
   Сначала она определяет физическую вершину
   области стека (на основе символа stacks и STACK_SIZE),
   а затем прибавляет KERNEL_VIRTUAL_OFFSET
   (разницу между KERNEL_VIRTUAL_BASE
   и физическим адресом загрузки ядра),
   чтобы установить указатель стека (sp)
   по его окончательному виртуальному адресу.

   Базовый адрес стека выравнивается по границе страницы,
   что обеспечивает соблюдение требований RISC-V ABI
   к выравниванию указателя стека.
   На данном этапе ядро работает,
   исходя из информации о своем
   актуальном физическом расположении в памяти,
   определенном при загрузке OpenSBI.

   #### 3.4.1.3 Первичная релокация ядра

   Безопасная ОС компилируется как
   позиционно-независимый исполняемый файл (PIE),
   что позволяет загружать её
   по произвольным физическим адресам,
   в то время как её внутренние компоненты
   компонуются для работы из верхнего диапазона
   виртуального адресного пространства,
   заданного параметром KERNEL_VIRTUAL_BASE.
   Для реализации этой возможности
   на начальном этапе настройки MMU выполняется
   первичная релокация путем создания
   отображения для
   сегментов кода и данных ядра в начальных таблицах страниц

   Создается тождественное отображение
   (физический адрес равен виртуальному)
   для той области, куда физически загружено ядро.
   Это гарантирует непрерывность выборки инструкций
   с физического адреса загрузки
   ядра сразу после активации MMU.

   #### 3.4.1.4 Активация MMU

   После того как таблицы страниц
   заполнены тождественным отображением
   и отображением на KERNEL_VIRTUAL_BASE для ядра,
   активируется модуль управления памятью (MMU).
   Это достигается путем конфигурирования
   регистра SATP (Supervisor Address Translation and Protection).
   Процедура включения MMU записывает в SATP:

  1. Номер физической страницы (PPN)
     корневой таблицы страниц (полученный из
     физического адреса структуры ptable_cache).

  2. Режим трансляции адресов (Sv39 для 64-разрядных
     систем RISC-V, что соответствует
     значению MODE=8 в регистре SATP).

   Сразу после записи в SATP трансляция адресов
   становится активной для всех обращений к памяти из
   режима супервизора на данном ядре.
   Предварительно созданные отображения гарантируют
   непрерывность выполнения текущего кода.

  ### 3.4.2 Инициализация Безопасной ОС

  После перехода в среду C, завершив
  начальную настройку на уровне ассемблера и активацию MMU,
  Безопасная ОС запускает процедуру
  инициализации для запуска своих ключевых компонентов.

   #### 3.4.2.1 Регистрация консоли

   Первым шагом в среде C становится
   настройка канала вывода диагностической информации и журналов.

   Драйвер консоли, использующий сервисы консоли SBI
   инициализируется и регистрируется
   в качестве основного канала ввода-вывода
   посредством вызова sbi_register_console().

   Это позволяет использовать функции вывода
   на ранних этапах работы в S-режиме,
   что важно для отладки и информирования
   о ходе или ошибках на последующих этапах инициализации.

   #### 3.4.2.2 Инициализация таблиц страниц

   Хотя базовые отображения MMU уже активны,
   Безопасная ОС теперь детализирует свою
   схему распределения памяти,
   настраивая таблицы страниц более гранулярно.

   Основные структуры таблиц страниц ядра доинициализируются
   функцией mmu_init_kernel_page_table(),
   выходя за рамки первоначальных крупных,
   грубо гранулированных отображений, созданных в head.S.

   Затем менеджер виртуальной памяти (VMM)
   определяет и отображает различные области памяти:
   - Информация об доступных областях памяти
     собирается с помощью vmm_collect_regions().
   - Отдельные регионы, такие как
     Flattened Device Tree (FDT)
     и линейное отображение всей защищённой RAM,
     регистрируются как динамические области
     с использованием vmm_register_dynamic_region().
   - Секции кода и данных ядра затем отображаются
     на свои окончательные виртуальные адреса
     в таблицах страниц функцией vmm_map_kernel_regions().

   Этот процесс формирует окончательную схему
   виртуальной памяти ядра, открывая возможности
   для постраничной защиты и динамического выделения памяти.

   #### 3.4.2.3 Вторичное перемещение ядра

   Далее ядро обеспечивает размещение всех своих компонентов
   по верхним виртуальным адресам, определённым на этапе компоновки:

  - Функция vmm_relocate_kernel_regions() выполняет
    переотображение секций ядра на виртуальные адреса
    2х верхних ГиБ виртуального адресного пространства.

  - Временные тождественные отображения,
    созданные во время начальной активации MMU,
    для раннего выполнения кода,
    очищаются.

   Затем ядро выполняет переход
   с текущего адреса счетчика команд
   на соответствующее смещение нового положения кода.
   Это действие полностью переносит исполнение
   в виртуальное адресное пространство ядра,
   обеспечивая корректную работу среды выполнения
   C и доступ к глобальным символам
   по их виртуальным адресам, заданным на этапе компоновки.

   #### 3.4.2.4 Инициализация обработчика перерываний

   Для обработки исключений, прерываний
   и системных вызовов Безопасная ОС настраивает
   свои механизмы обработки прерываний.

   Функция vector_table_init() вызывается
   для конфигурации вектора прерываний S-режима,
   направляя исключения и прерывания ЦП
   в центральный диспетчер прерываний Безопасной ОС.

   Это включает настройку обработчиков
   для синхронных исключений
   (таких как системные вызовы из Доверенных Приложений),
   асинхронных прерываний
   (например, от таймера, межпроцессорных прерываний - IPI)
   и ошибочных состояний.

   #### 3.4.2.5 Инициализация таймеров

   Таймеры используются для планировании задач
   и учёте времени в Безопасной ОС.

   Сначала инициализируется аппаратура таймеров,
   специфичная для платформы,
   с использованием информации из FDT,
   посредством вызова arch_timer_init(fdt).
   Это настраивает базовый аппаратный таймер
   для генерации периодических прерываний.

   Затем подсистема таймеров ядра
   инициализируется функцией timer_init().
   В ходе этого процесса настраиваются
   программные структуры таймеров,
   и система подготавливается
   к использованию аппаратного таймера
   для генерации тиков планировщика
   и управления событиями, привязанными ко времени.

   #### 3.4.2.6 Инициализация аллокатора страниц

   Для управления физической памятью,
   доступной Защищённому Миру,
   используеься аллокатор физических страниц.

   Схема распределения памяти Безопасной ОС,
   включая доступные регионы RAM,
   определяется функцией arch_mem_initilize(fdt).

   Затем инициализируется
   менеджер физической памяти (PMM) с помощью pmm_init().
   Эта функция создаёт структуры данных
   (списки свободных страниц и битовые карты)
   для отслеживания состояния всех страниц физической памяти,
   выделенных для использования в защищённом режиме,
   обеспечивая возможность динамического
   выделения и освобождения страниц.

   #### 3.4.2.7 Инициализация slab-аллокатора

   Для эффективного управления небольшими,
   часто выделяемыми объектами ядра,
   поверх аллокатора страниц создаётся slab-аллокатор.

   Функция kernel_slabs_init()
   инициализирует slab-аллокатор.
   Это подразумевает создание кэшей
   для объектов различных распространённых размеров,
   что уменьшает фрагментацию
   и повышает производительность
   выделения и освобождения структур данных ядра
   (например, блоков управления задачами,
   структур потоков, буферов сообщений IPC).

   #### 3.4.2.8 Инициализация планировщика

   Планировщик отвечает за управление
   выполнением потоков в Безопасной ОС.

   Базовые структуры для управления задачами
   подготавливаются функцией init_system_task(),
   которая настраивает начальные контексты
   задач ядра или idle поток.

   Далее настраиваются структуры
   данных планировщика: очереди готовых задач,
   и планировщик интегрируется с подсистемой таймеров
   инициализированной через timer_init()
   для обеспечения вытесняющего планирования
   с квантованием времени на основе политики Round-Robin.

   #### 3.4.2.9 Инициализация Root Task

   Корневая Задача - это компонент,
   выступающий в роли первого процесса
   в Защищённом Мире.
   Она отвечает за управление Доверенными Приложениями
   и обработку запросов взаимодействия между мирами.

   После инициализации планировщика вызывается spawn_root_task()
   Это включает загрузку ELF-файла Корневой Задачи,
   настройку её выделенного адресного пространства,
   выделение начальных ресурсов
   (включая дескрипторы, указанные в её манифесте),
   создание основного потока,
   и подготовку к обработке запросов.

   #### 3.4.2.10 Инициализация канала связи с Обычным Миром

   Для обеспечения взаимодействия с Linux
   инициализируется выделенная коммуникационная инфраструктура.

   Функция nwd_channel_init(fdt) настраивает очереди
   в разделяемой памяти. Этот процесс включает:

  - Определение областей физической памяти
    для очередей запросов и ответов на основе информации из FDT.

  - Отображение разделяемых страниц в адресное пространство Безопасной ОС.

  - Инициализацию структур данных для lock-free
    очередей MPMC как для запросов, так и для ответов.

   #### 3.4.2.11 Инициализация Доверенных Приложений

   Хотя большинство Доверенных Приложений (ДП)
   запускаются динамически Корневой Задачей
   по запросу из Обычного Мира через TEEC_OpenSession,
   на данном этапе производится запуск серсисов ДСИ,
   таких, как сервисы криптостойкого генератора случайных чисел,
   сервиса вычисления криптографических хешей.

 ## 3.5. Межмировая коммуникация

  ### 3.5.1. Lock-Free Алгоритм Очереди

   #### 3.5.1.1 Введение в Lock-Free алгоритмы

   Взаимодействие между Обычным миром (Linux)
   и Защищённым миром (Secure OS)
   основано на использовании очередей
   в разделяемой памяти.
   Для обеспечения эффективного
   и безопасного параллельного доступа
   из обоих миров без использования
   традиционных блокировок применяется Lock-Free алгоритм очереди типа
   "Множество Производителей - Множество Потребителей" (MPMC).

   Lock-Free алгоритмы - это класс параллельных алгоритмов,
   гарантирующих общесистемный прогресс:
   если один или несколько потоков выполняют
   операции над структурой данных,
   по крайней мере один поток должен завершить
   свою операцию за конечное число собственных шагов,
   независимо от состояния
   (например, приостановка, сбой) других потоков.

   Lock-Free алгоритмы обычно полагаются
   на атомарные аппаратные примитивы,
   такие как CAS или LL/SC,
   для управления одновременными изменениями состояния.

   #### 3.5.1.2 Алгоритм MPMC-очереди

   Выбранная MPMC-очередь представляет собой
   ограниченную очередь на основе массива
   (кольцевого буфера), разработанную
   для высокой производительности за счет
   использования атомарных операций
   и тщательного управления порядковыми номерами
   для координации производителей и потребителей.

   #### 3.5.1.2 Концепция Алгоритма

   Каждая ячейка в кольцевом буфере очереди
   ассоциируется с порядковым номером seq.
   Производители и потребители используют
   глобальные атомарные счетчики enqueue и dequeue соответственно
   для получения доступа к определенным логическим ячейкам.
   Производитель, пытающийся записать данные
   в логическую ячейку pos,
   может сделать это только в том случае,
   если seq целевой физической ячейки совпадает с pos.

   После записи производитель обновляет seq ячейки до pos + 1.
   Потребитель, пытающийся прочитать данные
   из логической ячейки pos, может сделать это только в том случае,
   если seq целевой физической ячейки
   совпадает с pos + 1.

   После чтения потребитель обновляет seq ячейки до pos + N
   (где N - вместимость очереди),
   помечая ее доступной для будущей операции постановки в очередь.

   Эта схема гарантирует,
   что ячейки обрабатываются по порядку
   и корректно передаются между производителями и потребителями.

   #### 3.5.1.3. Структуры данных

   Реализация очереди использует две основные структуры:

   mpmc_queue Представляет собой разделяемую очередь.

   ```c
   typedef struct {
       // Указатель на буфер с ячейками queue_cell
       void *data;

       // Маска для вычисления индекса в кольцевом буфере (ёмкость - 1)
       size_t size_mask;

       // Размер одной ячейки queue_cell (включая данные)
       size_t cell_size;

       // Размер пользовательских данных внутри ячейки
       size_t data_size;

       // Глобальный счетчик для следующей ячейки на постановку в очередь
       _Atomic size_t enqueue cacheline_aligned;

       // Глобальный счетчик для следующей ячейки на извлечение из очереди
       _Atomic size_t dequeue cacheline_aligned;
   } mpmc_queue;
   ```

   Счетчики enqueue и dequeue выровнены
   по границе кэш-линии (cacheline_aligned) во избежание
   ложного разделения (false sharing) между ядрами,
   которые могут одновременно пытаться
   добавлять и извлекать элементы.

   Вместимость очереди должна быть степенью двойки,
   что позволяет эффективно вычислять индекс с помощью size_mask.

   queue_cell Представляет отдельную ячейку в очереди.
   ```c
   typedef struct {
       // Порядковый номер для этой ячейки
       _Atomic int seq;

       // Данные пользователя
       unsigned char data[];
   } queue_cell;
   ```

   Поле seq является атомарным,
   так как это основной механизм синхронизации
   между производителями и потребителями для данной ячейки.

   ##### 3.5.1.4. Инициализация

   Функция mpmc_queue_init инициализирует очередь:

  1. Передаются указатель на буфер для хранения элементов,
     его общий размер, размер элементов данных
     и вычисленный размер ячейки.

  2. Атомарные счетчики enqueue и dequeue
     инициализируются нулем с использованием
     atomic_store_explicit с семантикой RELAXED.

  3. Рассчитывается size_mask как ёмкость - 1.

  4. Поле seq каждой структуры queue_cell
     с индексом i в буфере инициализируется значением i
     Такое состояние (cell[i].seq == i) означает,
     что ячейка i готова для i-ой операции
     постановки в очередь
     (т.е. когда глобальный счетчик enqueue равен i).

   ##### 3.5.1.5. Операция постановки в очередь

   Производитель, желающий добавить элемент в очередь,
   выполняет следующие шаги:

  1. Атомарно считывается текущее значение счетчика enqueue, pos.
     pos - логическая ячейка,
     которую производитель намеревается заполнить.

  2. Попытка занять ячейку: <br>
     - Вычисляется индекс физической ячейки
     - Атомарно считывается seq из cell[idx] с семантикой ACQUIRE.
       Это гарантирует видимость любых предшествующих записей
       в эту ячейку (например, потребителем, освободившим её).
     - Проверяется, равно ли cell[idx].seq значению pos.
       Если да, то потребитель захватил ячейку pos.
       Иначе, попытка повторяется до достижения успеха.

  3. После успешного захвата ячейки,
     данные пользователя копируются в ячейку

  4. Атомарно записывается pos + 1 в cell[idx].seq
     с семантикой RELEASE.
     Это делает запись данных видимой
     для потребителей и сигнализирует,
     что pos-й элемент готов к извлечению.

   ##### 3.5.1.6. Операция извлечения из очереди

   Потребитель, желающий извлечь элемент из очереди,
   выполняет следующие шаги:

  1. Атомарно считывается текущее значение счетчика enqueue, pos.
     pos - логическая ячейка,
     которую потребитель намеревается прочитать.

  2. Попытка занять ячейку: <br>
     - Вычисляется индекс физической ячейки
     - Атомарно считывается seq из cell[idx] с семантикой ACQUIRE.
       Это гарантирует видимость любых предшествующих записей
       в эту ячейку (например, потребителем, освободившим её).
     - Проверяется, равно ли cell[idx].seq значению pos.
       Если да, то потребитель захватил ячейку pos.
       Иначе, попытка повторяется до достижения успеха.

  3. После успешного захвата элемента,
     данные копируются в буфер пользователя.

  4. Атомарно записывается pos + queue->size_mask + 1
     в cell[idx].seq с семантикой RELEASE.
     Это помечает ячейку как пустую
     и доступную для будущей операции enqueue.

  ### 3.5.2. Очереди в разделяемой памяти

   #### 3.5.2.1 Кольцевые буферы в разделяемой памяти

   Межмировое взаимодействие основывается
   на использовании очередей в разделяемой памяти.
   Эти очереди реализованы как кольцевые буферы,
   расположенные в областях памяти,
   доступных как Обычному миру, так и Защищённому.

   Коммуникационные очереди физически
   представляют собой кольцевые буферы,
   размещённые на двух специально выделенных
   страницах физической памяти.

   Конфигурация этих страниц осуществляется
   Безопасной ОС с помощью расширения WorldGuard,
   которое предоставляет Защищённому и Обычному мирам
   разделяемый доступ на чтение и запись.
   При этом права доступа для каждой очереди
   настраиваются в соответствии с ее
   специфической ролью (производитель или потребитель).

   Каждый кольцевой буфер - это циклический массив
   ячеек фиксированного размера,
   предназначенных для хранения структур wg_tee_cmd.

   Важным аспектом является выравнивание памяти.
   Сама структура mpmc_queue выравнивает свои
   поля по границам кэш-линий.
   Это минимизирует ложное разделение (false sharing)
   между ядром ЦП, на котором работает Безопасная ОС,
   и ядрами, исполняющими Linux.
   Слоты для сообщений в кольцевом буфере
   выровнены по 256 байт для размещения структур,
   что предотвращает падение производительности
   из-за невыровненных обращений.

   #### 3.5.2.2 Очередь запросов

   Один из кольцевых буферов,
   расположенный на выделенной странице разделяемой памяти,
   используется в качестве Очереди Запросов.
   В этой схеме Обычный мир (драйвер Linux)
   выступает в роли производителя,
   помещая в очередь запросы,
   предназначенные для обработки Защищённым миром.
   Безопасная ОС, соответственно,
   является потребителем данной очереди.

   Процесс постановки запроса в очередь
   со стороны Обычного мира выглядит следующим образом:

  1. Драйвер Linux формирует команду TEE
     в виде структуры wg_tee_cmd.

  2. Драйвер пытается поместить данную структуру
     в свободный слот Очереди Запросов,
     используя операцию mpmc_queue_push.
     Эта функция сама находит свободный слот
     и атомарно обновляет счётчики данной очереди.

  3. В случае успешного добавления команды в очередь,
     драйвер Linux отправляет
     Межпроцессорное Прерывание (IPI)
     ядру Безопасной ОС,
     уведомляя его о появлении нового запроса

   #### 3.5.2.3 Очередь ответов

   Второй кольцевой буфер отведен
   под Очередь Ответов и располагается
   на другой странице разделяемой памяти.
   Здесь Безопасная ОС выступает производителем,
   помещая в очередь результаты обработки команд
   TEE или уведомления о событиях.
   Обычный мир (драйвер Linux),
   в свою очередь, является потребителем.

   Безопасная ОС помещает ответ в очередь следующим образом:

  1. Заполняет структуру wg_tee_cmd данными,
     содержащими результат выполненной операции.

  2. Помещает эту структуру в Очередь Ответов,
     используя функцию mpmc_queue_push.
     При этом атомарно обновляя счётчики Очереди Ответов.

  3. Драйвер Обычного мира использует
     механизм опроса (polling)
     для периодической проверки
     Очереди Ответов на наличие готовых результатов.

   #### 3.5.2.4 Канареечные страницы вокруг разделяемых страниц

   Для обнаружения и предотвращения
   ситуаций переполнения или опустошения буфера
   (buffer overflow/underflow)
   на страницах очередей в разделяемой памяти
   используются так называемые канареечные страницы.

   В процессе инициализации Безопасная ОС настраивает
   правила WorldGuard для физических страниц,
   непосредственно примыкающих (с обеих сторон)
   к двум страницам разделяемой памяти,
   используемым для очередей.

   Этим канареечным страницам WorldGuard
   назначает права доступа,
   полностью запрещающие любые операции
   (чтение, запись, исполнение)
   как со стороны WID 0 (Защищённый мир),
   так и со стороны WID 1 (Обычный мир).
   Если в результате ошибочной операции какой-либо
   из миров попытается обратиться
   к памяти за пределами выделенных границ разделяемой очереди,
   это приведёт к обращению к одной
   из таких канареечных страниц.
   Попытка несанкционированного доступа
   вызовет аппаратное исключение.

   Это позволяет системе обнаружить
   подобные нарушения безопасности памяти
   и предпринять адекватные меры,
   например, зарегистрировать ошибку
   или принудительно завершить вызвавший её компонент.

  ### 3.5.3 Области разделяемой памяти
  Помимо основных очередей,
  используемых для обмена управляющими командами и ответами,
  система поддерживает динамическое выделение
  и совместное использование
  более крупных областей памяти.
  Эти области предназначены для
  эффективной передачи больших объемов данных
  между Обычным миром и доверенными приложениями,
  исполняющимися в Безопасном мире.

   #### 3.5.3.1 Выделение области памяти

   Выделение области разделяемой памяти
   инициируется Обычным миром (Linux)
   путем вызова защищенной операции TEE_CMD_ID_MAP_SHARED_MEM.
   Безопасная ОС обрабатывает этот запрос следующим образом:

  1. Выделение страниц в Безопасном мире: <br>
     Безопасная ОС выделяет запрошенное
     количество страниц физической памяти
     из собственного управляемого пула.

  2. Настройка доступа: <br>
     Для выделенных страниц конфигурируются
     правила контроллера WorldGuard,
     предоставляющие права на одновременный доступ
     (например, чтение, запись)
     как Безопасному миру
     (действующему от имени доверенного приложения),
     так и Обычному миру.

  3. Отображение в Безопасной ОС: <br>
     Безопасная ОС отображает
     выделенные физические страницы
     в адресное пространство своего ядра.
     Это позволяет самой Безопасной ОС,
     а также доверенному приложению,
     для которого предназначается память,
     обращаться к этой разделяемой области.

  4. Отображение в Обычном мире: <br>
     После успешного выделения памяти
     и настройки прав доступа в Безопасном мире,
     драйвер Linux получает физический адрес
     и размер разделяемой области.
     Затем драйвер отвечает за отображение
     этих физических страниц в
     виртуальное адресное пространство ядра Linux,
     делая регион доступным для Обычного мира.
     В Обычный мир также возвращается
     идентификатор этой области разделяемой памяти (shmem_id),
     который используется для последующих обращений к ней.

   #### 3.5.3.2 Освобождение области памяти

   Освобождение памяти инициируется
   Обычным миром через вызов защищенной операции
   TEE_CMD_ID_UNMAP_SHARED_MEM,
   с указанием идентификатора shmem_id,
   полученного на этапе выделения.
   Безопасная ОС выполняет этот запрос, следуя следующим шагам:

  1. Отзыв прав в Безопасном мире: <br>
     Безопасная ОС сначала удостоверяется,
     что соответствующее доверенное приложение
     (если оно есть) прекратило использовать
     данную область памяти.
     После этого она перенастраивает
     правила контроллера WorldGuard
     для физических страниц этой разделяемой области,
     отзывая все права доступа как для Безопасного,
     так и для Обычного мира.

  2. Отмена отображения в Безопасной ОС: <br>
     Безопасная ОС удаляет отображение региона
     из адресного пространства своего ядра.

  3. Физическое освобождение страниц: <br>
     Физические страницы возвращаются
     в пул свободной памяти,
     управляемый Безопасной ОС.

  4. Отмена отображения в Обычном мире: <br>
     После того, как Безопасная ОС
     подтвердит успешное освобождение,
     драйвер Linux удаляет отображение
     соответствующей области памяти
     из виртуального адресного пространства ядра Linux,
     тем самым освобождая занимаемые ею виртуальные адреса.

   #### 3.5.3.3 Передача данных

   Когда область разделяемой памяти выделена
   и отображена в виртуальные адресные пространства
   ядра Linux и Безопасной ОС
   (что обеспечивает к ней доступ для доверенного приложения),
   передача данных между мирами осуществляется напрямую,
   с помощью стандартных операций чтения и записи в память.
